
import os
from typing import List, Optional, Dict, Any
from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel
from .config import MultiDirConfig
from .aggregator import MultiDirAggregator

router = APIRouter()

# In-process singleton (the host app can rebind via /reload)
_state = {
    "cfg": None,       # type: Optional[MultiDirConfig]
    "aggr": None,      # type: Optional[MultiDirAggregator]
}

class ConfigPayload(BaseModel):
    roots: List[str]
    excel_patterns: Optional[List[str]] = None
    allowed_exts: Optional[List[str]] = None
    schema_hints: Optional[Dict[str, Dict[str, str]]] = None

class SearchPayload(BaseModel):

class LoginPayload(BaseModel):
    password: str

@router.post("/login")
def login(payload: LoginPayload) -> Dict[str, Any]:
    """Simple password check and token issuance for legacy clients."""
    expected = os.environ.get("M_DIRS_PASSWORD", "1982567")
    if str(payload.password) == str(expected):
        # 这里不做真实会话校验，仅返回一个兼容 token，后续接口目前也不校验 X-Auth
        return {"ok": True, "token": "mdirs-token"}
    raise HTTPException(status_code=401, detail="Invalid password")

    project_like: Optional[str] = None
    unit_like: Optional[str] = None
    sign_method: Optional[str] = None
    sign_date_like: Optional[str] = None  # 'YYYY' or 'YYYY-MM' or 'YYYY-MM-DD'
    contract_no_like: Optional[str] = None
    contract_amount_like: Optional[str] = None
    limit: int = 200

@router.get("/config", response_model=ConfigPayload)
def get_config() -> Any:
    if _state["cfg"] is None:
        raise HTTPException(status_code=404, detail="Multi-directory config not initialised.")
    cfg = _state["cfg"]
    return ConfigPayload(
        roots=cfg.roots,
        excel_patterns=cfg.excel_patterns,
        allowed_exts=cfg.allowed_exts,
        schema_hints=cfg.schema_hints or {},
    )

@router.post("/reload")
def reload_config(payload: ConfigPayload) -> Dict[str, Any]:
    cfg = MultiDirConfig(
        roots=payload.roots,
        excel_patterns=payload.excel_patterns or MultiDirConfig([]).excel_patterns,
        allowed_exts=payload.allowed_exts or MultiDirConfig([]).allowed_exts,
        schema_hints=payload.schema_hints or {},
    )
    aggr = MultiDirAggregator(cfg)
    aggr.load()
    _state["cfg"] = cfg
    _state["aggr"] = aggr
    return {
        "ok": True,
        "records_loaded": len(aggr.records()),
        "roots": cfg.roots,
    }

@router.post("/search")
def search(payload: SearchPayload) -> Dict[str, Any]:
    if _state["aggr"] is None:
        raise HTTPException(status_code=400, detail="Not loaded. Call /api/mdirs/reload first.")
    items = _state["aggr"].search(
        project_like=payload.project_like,
        unit_like=payload.unit_like,
        sign_method=payload.sign_method,
        sign_date_like=payload.sign_date_like,
        contract_no_like=payload.contract_no_like,
        contract_amount_like=payload.contract_amount_like,
        limit=payload.limit,
    )
    # Output fields order normalized
    return {
        "count": len(items),
        "items": items,
    }

@router.post("/paged_search")
async def paged_search(payload: SearchPayload, request: Request) -> Dict[str, Any]:
    """
    与 /search 参数一致，但从请求体里读取 offset/skip 做分页切片，
    返回 count=总条数，items=当页数据
    """
    if _state["aggr"] is None:
        raise HTTPException(status_code=400, detail="Not loaded. Call /api/mdirs/reload first.")
    data = await request.json()
    start = data.get("skip") if data.get("skip") is not None else data.get("offset", 0)
    try:
        start = int(start)
    except Exception:
        start = 0
    if start < 0:
        start = 0

    all_items = _state["aggr"].search(
        project_like=payload.project_like,
        unit_like=payload.unit_like,
        sign_method=payload.sign_method,
        sign_date_like=payload.sign_date_like,
        contract_no_like=payload.contract_no_like,
        contract_amount_like=payload.contract_amount_like,
        limit=10_000_000,  # 取全量后端再切
    )
    end = start + (payload.limit or 200)
    page_items = all_items[start:end]
    return {"count": len(all_items), "items": page_items}
